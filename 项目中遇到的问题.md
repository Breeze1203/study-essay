项目中遇到的问题

###### 关于登录过程中，动态加载路由，一些路由不需显示的问题 ：

解决办法：在特定的路由中加入hidden属性，通过判断值true/false

```js
import { createRouter, createWebHistory } from 'vue-router'


const routes = [
  {
    path: '/',
    name: 'login',
    hidden:false,
    component: () => import('../views/Login.vue')
  },
  {
    path: '/Home',
    name: 'Home',
    hidden:true,
    component: () => import('../components/Home.vue'),
    children:[
      {
        path:'/text',
        name:'Text',
        component:()=>import('../components/text.vue')
      }
    ]
  },
  {
    path:'/text2',
    name:'Text',
    hidden:true,
    component:()=>import('../components/text2.vue')
  }
]

const router = createRouter({
  history: createWebHistory(process.env.BASE_URL),
  routes
})

export default router
```

通过v-if实现判断

```vue
<el-aside width="200px">
                    <el-menu @select="handleOpen" v-for="(item,index) in this.$router.options.routes">
                        <el-sub-menu index="1" v-if="item.hidden">
                            <template #title>
                                <el-icon></el-icon>
                                <span>{{ item.name }}</span>
                            </template>
                            <el-menu-item :index="child.path" v-for="(child,indexj) in item.children">{{ child.name }}</el-menu-item>
                    </el-sub-menu>
                    </el-menu>
                </el-aside>
```

动态路由的添加，关于router.addRoutes();

新版VueRouter废除了addRoutes();//添加的数组
改为addRoute(RouteRecordRaw);//添加的为对象
原代码为：

```vue
const routers = store.getters.addRouters;
router.addRoutes(routers);
```

改为:

```vue
const routers = store.getters.addRouters;
routers.forEach((route) => {
  router.addRoute(route);
});
```

从数据库动态提取权限路由菜单这块：

```js
import request from "@/api/request";

export const initMenu = (router, store) => {
    request.menuinit().then(resp => {
        console.log(resp.data);
        let b=formatRoutes(resp.data);
        for(var i=0;i<b.length;i++){
            router.addRoute(b[i]);
        }
    })
}

// 此时参数routes是后端查询返回的路由参数
export const formatRoutes = (num) => {
    let rou = [];
    // 遍历routes 可以看到后端返回的数据是数组里面包含多个对象
    for (var i = 0; i < num.length; i++) {
        // 将menus里面的属性批量赋值给属性
        let {name, meta, path, component, iconCls, children} = num[i];
        if (num[i].children != null && num[i].children instanceof Array) {
            // 递归调用
            children = formatRoutes(num[i].children);
        }
        let fmRouter = {
            path: path,
            name: name,
            meta: meta,
            iconCls: iconCls,
            children: children,
            component: () => {
                if (component.startsWith('Emp')) {
                    import('../components/emp/' + component + '/.vue');
                } else if (component.startsWith('txt')) {
                    import('../components/per/' + component + '/.vue');
                } else if (component.startsWith('Per')) {
                    import('../components/per/' + component + '/.vue');
                } else if (component.startsWith('Sal')) {
                    import('../components/sal/' + component + '/.vue');
                } else if (component.startsWith('Sta')) {
                    import('../components/sta/' + component + '/.vue')
                } else if (component.startsWith('Sys')) {
                    import('../components/sys/' + component + '/.vue')
                }
            }
        };
        rou.push(fmRouter);
    }
    return rou;
}
```

获取当前路由路径的name

```js
router.currentRoute 相当于 $route

但是$route.path或者$route.fullPath只能在组件中用   

组件里头：`/user?a=10` $route.path === /user  $route.fullPath === /user?a=10

js模块中要使用 router.currentRoute

// js模块中：router.currentRoute.value.fullPath 就是当前路由地址

2.router.currentRoute是ref响应式数据 要拿值的话需要.value

3.encodeURIComponent 转换uri编码，防止解析地址出问题 用来解析获得的fullPath中的特殊字符

const fullPath = encodeURIComponent(router.currentRoute.value.fullPath)
```

###### 关于路由守卫

最近因为next()遇到了不少问题，在这里记录一下

首先是路由守卫，是不是感觉简简单单

```javascript
beforeEach((to, from, next) => {

	to // 要去的路由

	from // 当前路由

	next() // 放行的意思

}
```


但是在看别的项目时常常能看到next('/logon') 、 next(to) 或者 next({ ...to, replace: true }) 这又是啥意思呢

其实在路由守卫中，只有next()是放行，其他的诸如：next('/logon') 、 next(to) 或者 next({ ...to, replace: true })都不是放行，而是：中断当前导航，执行新的导航

可以这么理解：
next() 是放行，但是如果next()里有参数的话，next()就像被重载一样，就有了不同的功能。

而对于上面说的中断当前导航，执行新的导航打个比方：

现在我有一个守卫，在守卫中我使用next('/logon')，肯定有同学认为是会直接跳转到/logon路由：

```javascript
beforeEach((to, from, next) => {

  next('/logon')

}

```


然而年轻人不讲武德，执行时需要这么看：

```javascript
beforeEach((to, from, next) => {

  beforeEach(('/logon', from, next) => {

  	 beforeEach(('/logon', from, next) => {

  	 	 beforeEach(('/logon', from, next) => {

  	 	 	beforeEac...  // 一直循环下去...... , 因为我们没有使用 next() 放行

 		}

 	 }

  }

```


如果把这个守卫改一下，当我在地址栏输入/home时

```javascript
beforeEach((to, from, next) => {

   if(to.path === '/home') {

   	next('/logon')

   } else {

    // 如果要去的地方不是 /home ， 就放行

   	next()

   }

}

```


我本来要去/home路由，因此执行了第一次 beforeEach((to, from, next)

但是这个路由守卫中判断了如果要去的地方是'/home'，就执行next('/logon')，

所以想要访问/home可以这么看

```javascript
beforeEach((to, from, next) => {

   beforeEach(('/logon', from, next) => {

     next()  // 现在要去的地方不是 /home ， 因此放行

   }

}

```


注意：重点就在这，next('/logon')不是说直接去/logon路由，而是中断（不是CPU的那个中断！VUE中的中断就是此时不会执行router.afterEach(() => {}）这一次路由守卫的操作，又进入一次路由守卫，就像嵌套一样，一层路由守卫，然后又是一层路由守卫，此时路由守卫进入到第二层时，to.path已经不是/home了，这个时候才执行next()放行操作。

正以为如此很多人在使用动态添加路由addRoutes()会遇到下面的情况：
在addRoutes()之后第一次访问被添加的路由会白屏，这是因为刚刚addRoutes()就立刻访问被添加的路由，然而此时addRoutes()没有执行结束，因而找不到刚刚被添加的路由导致白屏。因此需要从新访问一次路由才行。

该如何解决这个问题 ?
此时就要使用next({ ...to, replace: true })来确保addRoutes()时动态添加的路由已经被完全加载上去。

next({ ...to, replace: true })中的replace: true只是一个设置信息，告诉VUE本次操作后，不能通过浏览器后退按钮，返回前一个路由。

因此next({ ...to, replace: true })可以写成next({ ...to })，不过你应该不希望用户在addRoutes()还没有完成的时候，可以点击浏览器回退按钮搞事情吧。

其实next({ ...to })的执行很简单，它会判断：

如果参数to不能找到对应的路由的话，就再执行一次beforeEach((to, from, next)直到其中的next({ ...to})能找到对应的路由为止。

也就是说此时addRoutes()已经完成啦，找到对应的路由之后，接下来将执行前往对应路由的beforeEach((to, from, next) ，因此需要用代码来判断这一次是否就是前往对应路由的beforeEach((to, from, next)，如果是，就执行next()放行。

如果守卫中没有正确的放行出口的话，会一直next({ ...to})进入死循环 !!!

因此你还需要确保在当addRoutes()已经完成时，所执行到的这一次beforeEach((to, from, next)中有一个正确的next()方向出口。

因此想实现动态添加路由的操作的话，代码应该是这样的：

```javascript
router.beforeEach((to, from, next) => {

 const token = sessionStorage.getItem('access_token')

 // 存在 token 说明已经登录

 if (token) {

   // 登录过就不能访问登录界面，需要中断这一次路由守卫，执行下一次路由守卫，并且下一次守卫的to是主页'

   if (to.path === '/login') {

     next({ path: '/' })

   }

   // 保存在store中路由不为空则放行 (如果执行了刷新操作，则 store 里的路由为空，此时需要重新添加路由)

   if (store.getters.getRoutes.length || to.name != null) {

     //放行

     next()

   } else {

     // 将路由添加到 store 中，用来标记已添加动态路由

     store.commit('ADD_ROUTER', '需要添加的路由')

     router.addRoutes('需要添加的路由')

     // 如果 addRoutes 并未完成，路由守卫会一层一层的执行执行，直到 addRoutes 完成，找到对应的路由

     next({ ...to, replace: true })

   }

 } else {

   // 未登录时，注意 ：在这里也许你的项目不只有 logon 不需要登录 ，register 等其他不需要登录的页面也需要处理

   if (to.path !== '/logon') {

     next({ path: '/logon' })

   } else {

     next()

   }

 }

```


万一还是听不懂，也可以next()比作Java Filter里的chain.doFilter(req, resp)
@WebFilter(filterName = "EncodingFilter", urlPatterns = "/*")
public class EncodingFilter implements Filter {

```java
@Override
public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
    // 设置编码
    req.setCharacterEncoding("utf-8");
    resp.setContentType("text/html;charset=utf-8");
    chain.doFilter(req, resp);  // next()
}
```

}



###### 权限控制：

1.从前端发起的http请求，拿到http请求后，先分析地址与menu表里哪个url所匹配，menu表里的id对应menu_role里面的mid，根据mid查询menu_role里的rid(对应用户角色)

2.判读当前登录用户是否具有发来请求查出的角色，如果具备，则正常访问，不具备，则无权访问

###### 关于将mybatis的xml文件放在java目录下面的坑

1.在pom.xml文件中将java目录注册为资源目录

```xml
  <build>
            <resources>
                <resource>
                    <directory>src/main/java</directory>
                    <includes>
                        <include>**/*.xml</include>
                    </includes>
                    <filtering>true</filtering>
                </resource>
            </resources>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

```

2.$\textcolor{red}{springboot的配置文件的路径 由 . 改为 /}$

```xml
mybatis:
  type-aliases-package: com.example.springboot_shiro.entity
  mapper-locations: com/example/springboot_shiro/mapper/UserMapper.xml
```

